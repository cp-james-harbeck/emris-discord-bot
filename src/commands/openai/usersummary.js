// Require dotenv to access environment variables
require('dotenv').config();

// Require classes/Commands and discord.js for ChatInputCommand and EmbedBuilder
const { ChatInputCommand } = require('../../classes/Commands');
const { EmbedBuilder } = require('discord.js');

// Require OpenAIManager to get GPT response
const OpenAIManager = require('../../handlers/openai/OpenAIManager');

// Function to summarize user messages within a given time period
async function summarizeUserMessageContent(user, messages, time_period) {
    // Create system content with user, messages, and time period
    const systemContent = `Friendly and concise. Please provde a detailed summary of the following messages from user ${user} in the past ${time_period} hours:\n\n${messages}`;
    
    // Get GPT response from OpenAIManager
    const aiResponse = await OpenAIManager.getGPTResponse(systemContent, systemContent);

    // Return summary or error message
    const summary = aiResponse ? aiResponse.trim() : 'Error: Unable to generate summary.';
    return summary;
}

// Options for user and channel autocomplete
const userAutoCompleteOption = {
    type: 6,
    name: 'user',
    description: 'User to generate a summary for',
    required: true,
};

const channelAutoCompleteOption = {
    type: 7,
    name: 'channel',
    description: 'Channel to generate a summary for',
    required: true,
};

// Export ChatInputCommand module
module.exports = new ChatInputCommand({
    global: true,
    aliases: ['usersummary'],
    cooldown: {
        type: 'user',
        usages: 2,
        duration: 10,
    },
    clientPerms: ['EmbedLinks'],
    data: {
        description: 'Generates a summary of user activities within the selected channels.',
        options: [{
                type: 3,
                name: 'time_period',
                description: 'Time period to summarize messages (24h, 7d, 30d)',
                required: true,
                choices: [{
                        name: 'Last 24 Hours',
                        value: '24h',
                    },
                    {
                        name: 'Last 7 Days',
                        value: '7d',
                    },
                    {
                        name: 'Last 30 Days',
                        value: '30d',
                    },
                ],
            },
            userAutoCompleteOption,
            channelAutoCompleteOption
        ]
    },
    run: async (client, interaction) => {
        console.log(interaction.options);
        const user = interaction.options.getUser('user');
        const time_period = interaction.options.getString('time_period');
        const channel = interaction.options.getChannel('channel');
        const hours = time_period === '24h' ? 24 : time_period === '7d' ? 168 : 720;

        const time_range_ms = hours * 60 * 60 * 1000;
        const messages = [];

        let last_message_id;
        let remaining_time = time_range_ms;

        // Fetch messages from channel within given time range
        do {
            const options = {
                limit: 100
            };
            if (last_message_id) {
                options.before = last_message_id;
            }

            const fetchedMessages = await channel.messages.fetch(options);
            if (!fetchedMessages.size) {
                break;
            }

            // Filter messages by user and time range
            const messagesInRange = fetchedMessages.filter((fetchedMessage) => {
                const created_at_utc = fetchedMessage.createdTimestamp;
                return Date.now() - created_at_utc <= remaining_time && fetchedMessage.author.id === user.id;
            });

            // Push message contents into messages array
            const messageContents = messagesInRange.map((message) => message.content);
            messages.push(...messageContents);

            last_message_id = fetchedMessages.last().id;
            remaining_time -= time_range_ms;
        } while (remaining_time > 0);

        const messages_str = messages.join('\n');
        if (messages_str) {
            await interaction.deferReply();
            const summary = await summarizeUserMessageContent(`<@${user.id}>`, `${user.username}#${user.discriminator}`, messages_str, hours);

            // Create embed with summary
            const embed = new EmbedBuilder()
                .setTitle(`Summary for ${user.username}#${user.discriminator}`)
                .setDescription(summary)
                .setColor(0x00ff00)
                .setTimestamp()
                .setFooter({
                    text: `Generated by ${client.user.username}`
                });

            await interaction.editReply({
                embeds: [embed]
            });
        } else {
            // Create embed with no messages found
            const embed = new EmbedBuilder()
                .setTitle(`Summary for ${user.username}#${user.discriminator}`)
                .setDescription('No messages were found.')
                .setColor(0xff0000)
                .setTimestamp()
                .setFooter({
                    text: `Generated by ${client.user.username}`
                });

            await interaction.deferReply();
            await interaction.editReply({
                embeds: [embed]
            });
        }
    },

    // Autocomplete function for user and channel
    autocomplete: async (interaction) => {
        const focusedOption = interaction.options.getFocused(true);

        if (focusedOption.name === 'user') {
            // Filter users by username and create array of objects
            const users = interaction.guild.members.cache
                .filter(member => member.user.username.toLowerCase().startsWith(focusedOption.value.toLowerCase()))
                .map(member => ({
                    name: member.user.tag,
                    value: member.user.id
                }));

            await interaction.respond(users);
        }

        if (focusedOption.name === 'channel') {
            // Filter channels by name and create array of objects
            const channels = interaction.guild.channels.cache
                .filter(channel => channel.type === 'GUILD_TEXT' && channel.name.toLowerCase().startsWith(focusedOption.value.toLowerCase()))
                .map(channel => ({
                    name: channel.name,
                    value: channel.id
                }));

            await interaction.respond(channels);
        }
    }
});