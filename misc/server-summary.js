// require('dotenv').config();
// const {
//     ChatInputCommand
// } = require('../../classes/Commands');
// const {
//     commandAutoCompleteOption
// } = require('../../interactions/autocomplete/command');
// const {
//     EmbedBuilder
// } = require('discord.js');
// const axios = require('axios');

// // The ID of the channel where the summary should be posted
// const SUMMARY_CHANNEL_ID = '1081914884767367168';

// async function summarizeServerMessages(client, channel, time_period) {
//     const text = `Friendly and concise. Please summarize all messages from the server in the past ${time_period} hours.`;

//     try {
//         const response = await axios.post(
//             'https://api.openai.com/v1/chat/completions', {
//                 model: 'gpt-3.5-turbo',
//                 messages: [{
//                         role: 'system',
//                         content: `You are a friendly and concise AI. Your task is to summarize all messages from the server.`,
//                     },
//                     {
//                         role: 'user',
//                         content: text,
//                     },
//                 ],
//                 temperature: 0.7,
//                 max_tokens: 300,
//             }, {
//                 headers: {
//                     'Content-Type': 'application/json',
//                     'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
//                 },
//             }
//         );

//         console.log(response.data);
//         const summary = response.data.choices[0].message.content ? response.data.choices[0].message.content.trim() : 'Error: Unable to generate summary.';

//         // Post the summary in the specified channel
//         const summaryChannel = client.channels.cache.get(SUMMARY_CHANNEL_ID);
//         if (summaryChannel) {
//             const embed = new EmbedBuilder()
//                 .setTitle(`Summary for the past ${time_period}`)
//                 .setDescription(summary)
//                 .setColor(0x00ff00)
//                 .setTimestamp()
//                 .setFooter({
//                     text: `Generated by ${client.user.username}`
//                 });

//             await summaryChannel.send({
//                 embeds: [embed]
//             });
//         } else {
//             console.error(`Unable to find channel with ID ${SUMMARY_CHANNEL_ID}`);
//         }
//     } catch (error) {
//         console.error(error);
//     }
// }

// module.exports = new ChatInputCommand({
//     global: true,
//     aliases: ['server-summary'],
//     cooldown: {
//         type: 'user',
//         usages: 2,
//         duration: 10,
//     },
//     clientPerms: ['EmbedLinks'],
//     data: {
//         description: 'Generates a summary of all server messages within the selected time period.',
//         options: [{
//             type: 3,
//             name: 'time_period',
//             description: 'Time period to summarize messages (12h, 24h, 7d)',
//             required: true,
//             choices: [{
//                     name: 'Last 12 Hours',
//                     value: '12h',
//                 },
//                 {
//                     name: 'Last 24 Hours',
//                     value: '24h',
//                 },
//                 {
//                     name: 'Last 7 Days',
//                     value: '7d',
//                 },
//             ],
//         }, ],
//     },
//     run: async (client, interaction) => {
//         console.log(interaction.options);
//         const time_period = interaction.options.getString('time_period');
//         const hours = time_period === '12h' ? 12 : time_period === '24h' ? 24 : 168;

//         const time_range_ms = hours * 60 * 60 * 1000;

//         // Get all channels in the server
//         const channels = client.guilds.cache
//         get(interaction.guildId)
//             .channels.cache
//             .filter(channel => channel.type === 'GUILD_TEXT');

//         for (const channel of channels) {
//             const messages = [];

//             let last_message_id;
//             let remaining_time = time_range_ms;

//             do {
//                 const options = {
//                     limit: 100
//                 };
//                 if (last_message_id) {
//                     options.before = last_message_id;
//                 }

//                 const fetchedMessages = await channel.messages.fetch(options);
//                 if (!fetchedMessages.size) {
//                     break;
//                 }

//                 const messagesInRange = fetchedMessages.filter((fetchedMessage) => {
//                     const created_at_utc = fetchedMessage.createdTimestamp;
//                     return Date.now() - created_at_utc <= remaining_time;
//                 });

//                 const messageContents = messagesInRange.map((message) => message.content);
//                 messages.push(...messageContents);

//                 last_message_id = fetchedMessages.last().id;
//                 remaining_time -= time_range_ms;
//             } while (remaining_time > 0);

//             const messages_str = messages.join('\n');
//             if (messages_str) {
//                 const summary = await summarizeServerMessages(client, channel, time_period);
//             } else {
//                 console.log(`No messages found in channel ${channel.name}`);
//             }
//         }
//     },

//     schedule: {
//         interval: '12h',
//         run: async (client) => {
//             const time_period = '12h';
//             const hours = 12;

//             const time_range_ms = hours * 60 * 60 * 1000;

//             // Get all channels in the server
//             const channels = client.guilds.cache
//                 .map(guild => guild.channels.cache.filter(channel => channel.type === 'GUILD_TEXT'))
//                 .flat();

//             for (const channel of channels) {
//                 const messages = [];

//                 let last_message_id;
//                 let remaining_time = time_range_ms;

//                 do {
//                     const options = {
//                         limit: 100
//                     };
//                     if (last_message_id) {
//                         options.before = last_message_id;
//                     }

//                     const fetchedMessages = await channel.messages.fetch(options);
//                     if (!fetchedMessages.size) {
//                         break;
//                     }

//                     const messagesInRange = fetchedMessages.filter((fetchedMessage) => {
//                         const created_at_utc = fetchedMessage.createdTimestamp;
//                         return Date.now() - created_at_utc <= remaining_time;
//                     });

//                     const messageContents = messagesInRange.map((message) => message.content);
//                     messages.push(...messageContents);

//                     last_message_id = fetchedMessages.last().id;
//                     remaining_time -= time_range_ms;
//                 } while (remaining_time > 0);

//                 const messages_str = messages.join('\n');
//                 if (messages_str) {
//                     const summary = await summarizeServerMessages(client, channel, time_period);
//                 } else {
//                     console.log(`No messages found in channel ${channel.name}`);
//                 }
//             }
//         },
//     },


//     autocomplete: async (interaction) => {
//         const focusedOption = interaction.options.getFocused(true);

//         // Add the required case for the command autocomplete option
//         if (focusedOption.name === 'command') {
//             const query = focusedOption.value;
//             const queryResult = await commandAutoCompleteOption.run(client, interaction, query);
//             await interaction.respond(queryResult);
//         }
//     },
// });